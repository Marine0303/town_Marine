<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>ステ繋げシミュレーション</title>
<style>
  :root{
    --pad:12px;
    --safeTop: env(safe-area-inset-top);
    --safeBot: env(safe-area-inset-bottom);
    --hdrH: 56px;
  }
  html,body{
    margin:0; height:100dvh; background:#050b1a; color:#e9eefc;
    font-family: system-ui,-apple-system,"Noto Sans JP",sans-serif;
    overflow:hidden;
  }
  /* ===== Top bar ===== */
  header{
    position:fixed; left:0; right:0; top:0; z-index:50;
    height: calc(var(--hdrH) + var(--safeTop));
    padding-top: var(--safeTop);
    background: rgba(8,14,34,.92);
    border-bottom:1px solid rgba(255,255,255,.10);
    backdrop-filter: blur(10px);
    display:flex; align-items:center; gap:10px;
    padding-left: var(--pad);
    padding-right: var(--pad);
    box-sizing: border-box;
  }
  .btn{
    background:#0f1b44; color:#e9eefc;
    border:1px solid rgba(255,255,255,.18);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    cursor:pointer;
    user-select:none;
  }
  .btn.primary{
    background: linear-gradient(180deg, rgba(50,120,255,.95), rgba(40,90,230,.95));
    font-weight:900;
  }
  .title{
    font-weight:900; letter-spacing:.2px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    opacity:.95;
  }
  .sp{flex:1}
  .pill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.05);
    font-size:12px; opacity:.9;
  }

  /* ===== Canvas ===== */
  #c{
    position:fixed;
    left:0; right:0;
    top: calc(var(--hdrH) + var(--safeTop));
    bottom: calc(44px + var(--safeBot));
    touch-action:none;
    background:#050b1a;
  }

  /* ===== Bottom HUD ===== */
  .hud{
    position:fixed; left:0; right:0;
    bottom:0;
    padding:10px var(--pad) calc(10px + var(--safeBot));
    box-sizing:border-box;
    background: rgba(8,14,34,.86);
    border-top:1px solid rgba(255,255,255,.10);
    backdrop-filter: blur(10px);
    display:flex; gap:10px; align-items:center;
    z-index:40;
  }
  .hud .box{
    flex:1;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    border-radius:14px;
    padding:10px;
    font-size:12px;
    line-height:1.2;
  }
  .hud .big{font-size:13px; font-weight:900}
  .hud .muted{opacity:.75}

  /* ===== Slide-up menu ===== */
  #sheetBack{
    position:fixed; inset:0;
    background: rgba(0,0,0,.45);
    z-index:80;
    display:none;
  }
  #sheet{
    position:fixed; left:0; right:0; bottom:0;
    z-index:90;
    transform: translateY(110%);
    transition: transform .22s ease;
    background: rgba(10,16,40,.98);
    border-top:1px solid rgba(255,255,255,.12);
    border-radius: 18px 18px 0 0;
    padding: 12px var(--pad) calc(12px + var(--safeBot));
    box-sizing:border-box;
    max-height: 74vh;
    overflow:hidden;
    backdrop-filter: blur(10px);
  }
  #sheet.open{ transform: translateY(0); }
  #sheetBack.open{ display:block; }

  .sheetTop{
    display:flex; align-items:center; gap:10px;
    padding-bottom:10px;
  }
  .drag{
    width:44px; height:5px; border-radius:999px;
    background: rgba(255,255,255,.22);
    margin: 2px auto 8px auto;
  }
  .sheetTitle{ font-weight:900; }
  .sheetBody{
    overflow:auto;
    max-height: calc(74vh - 90px);
    padding-right:6px;
  }

  .card{
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    border-radius:16px;
    padding:12px;
    margin-bottom:10px;
  }
  .row{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    margin-top:10px;
  }
  label.mini{ font-size:12px; opacity:.8; }
  input, select{
    background:#0f1b44; color:#e9eefc;
    border:1px solid rgba(255,255,255,.18);
    border-radius:12px;
    padding:10px 12px;
    font-size:14px;
    outline:none;
  }
  input[type="number"]{ width:88px; }
  input[type="text"]{ width:120px; }
  input[type="color"]{ width:54px; height:42px; padding:0 6px; }

  .grid2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .check{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    border-radius:14px;
    padding:10px;
  }
  .check .left{
    display:flex; align-items:center; gap:10px; min-width:0;
  }
  .dot{
    width:10px; height:10px; border-radius:50%;
    flex:0 0 auto;
  }
  .check .name{
    font-weight:900;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: 46vw;
  }
  .check .sub{ font-size:12px; opacity:.75; white-space:nowrap; }
  .check input{ transform: scale(1.2); }

  /* ===== Station detail mini-modal ===== */
  #detailBack{
    position:fixed; inset:0;
    background: rgba(0,0,0,.45);
    z-index:95;
    display:none;
  }
  #detail{
    position:fixed; left:10px; right:10px;
    top: calc(var(--hdrH) + var(--safeTop) + 10px);
    z-index:100;
    background: rgba(10,16,40,.98);
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    padding:12px;
    display:none;
    backdrop-filter: blur(10px);
  }
  #detail .top{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    margin-bottom:10px;
  }
  #detail .top .t{font-weight:900}
  #detail .top .x{opacity:.8}
  #toast{
    position:fixed; left:50%; bottom: calc(68px + var(--safeBot));
    transform: translateX(-50%);
    background: rgba(0,0,0,.72);
    color:#fff;
    padding:10px 14px;
    border-radius:999px;
    font-size:13px;
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease;
    z-index:120;
  }
  #toast.show{ opacity:1; }
</style>
</head>
<body>

<header>
  <button id="menuBtn" class="btn">☰</button>
  <div class="title">WOS 旗ルート</div>
  <div class="sp"></div>
  <span id="selPill" class="pill">選択 0</span>
  <button id="routeBtn" class="btn primary">ルート</button>
</header>

<canvas id="c"></canvas>

<div class="hud">
  <div class="box">
    <div class="big">タップ座標</div>
    <div id="tapXY" class="muted">X: -  /  Y: -</div>
  </div>
  <div class="box">
    <div class="big">HQ</div>
    <div id="hqXY" class="muted">X: 520 / Y: 520</div>
  </div>
  <button id="fullBtn" class="btn">全体</button>
  <button id="resetBtn" class="btn">リセット</button>
</div>

<!-- Slide-up menu -->
<div id="sheetBack"></div>
<div id="sheet">
  <div class="drag"></div>
  <div class="sheetTop">
    <div class="sheetTitle">メニュー</div>
    <div class="sp"></div>
    <button id="closeSheet" class="btn">閉じる</button>
  </div>
  <div class="sheetBody">
    <div class="card">
      <div style="font-weight:900;">同盟 / HQ</div>
      <div class="row">
        <label class="mini">同盟</label>
        <input id="allyName" type="text" value="N9Q">
        <label class="mini">色</label>
        <input id="allyColor" type="color" value="#2b7cff">
      </div>
      <div class="row">
        <label class="mini">HQ X</label>
        <input id="hqX" type="number" value="520">
        <label class="mini">HQ Y</label>
        <input id="hqY" type="number" value="520">
        <button id="applyHQ" class="btn">座標反映</button>
        <button id="placeHQ" class="btn">マップで置く</button>
      </div>
      <div style="font-size:12px; opacity:.75; margin-top:8px; line-height:1.25;">
        ・「マップで置く」→ 次にマップをタップした場所にHQを置きます<br>
        ・黄色ゾーン（太陽城周り）は通行不可：ルートは必ず回避します
      </div>
    </div>

    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
        <div style="font-weight:900;">占領ステ効果（Lv違いは重ねがけ可）</div>
        <button id="clearSel" class="btn">全外し</button>
      </div>
      <div id="checkGrid" class="grid2" style="margin-top:10px;"></div>
      <div style="font-size:12px; opacity:.75; margin-top:8px; line-height:1.25;">
        チェック → <strong>HQから最寄りの該当ステ（同効果+Lv）を1つだけ</strong>自動採用 → ルート作成
      </div>
    </div>

    <div class="card">
      <div style="font-weight:900;">便利</div>
      <div class="row">
        <button id="copyRoute" class="btn">採用一覧コピー</button>
        <button id="goSun" class="btn">太陽城へ</button>
        <button id="saveBtn" class="btn">保存(JSON)</button>
        <button id="loadBtn" class="btn">読込(JSON)</button>
      </div>
      <div style="font-size:12px; opacity:.75; margin-top:8px;">
        マップ操作：1本指ドラッグで移動 / ピンチで拡大縮小 / ステをタップで詳細
      </div>
    </div>
  </div>
</div>

<!-- Station detail -->
<div id="detailBack"></div>
<div id="detail">
  <div class="top">
    <div class="t" id="dTitle">ステ詳細</div>
    <button id="dClose" class="btn x">×</button>
  </div>
  <div id="dSub" style="font-size:12px; opacity:.8; margin-bottom:10px;">(x,y)</div>
  <div class="row">
    <label class="mini">効果</label>
    <select id="dEffect"></select>
    <label class="mini">Lv</label>
    <select id="dLv">
      <option value="1">Lv1</option>
      <option value="2">Lv2</option>
      <option value="3">Lv3</option>
    </select>
    <button id="dSave" class="btn primary">割当保存</button>
  </div>
  <div class="row">
    <button id="dCopy" class="btn">詳細コピー</button>
  </div>
</div>

<div id="toast"></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ===== UI refs =====
  const menuBtn = document.getElementById("menuBtn");
  const routeBtn = document.getElementById("routeBtn");
  const fullBtn = document.getElementById("fullBtn");
  const resetBtn = document.getElementById("resetBtn");
  const selPill = document.getElementById("selPill");
  const tapXY = document.getElementById("tapXY");
  const hqXY = document.getElementById("hqXY");

  const sheetBack = document.getElementById("sheetBack");
  const sheet = document.getElementById("sheet");
  const closeSheet = document.getElementById("closeSheet");

  const allyNameEl = document.getElementById("allyName");
  const allyColorEl = document.getElementById("allyColor");
  const hqXEl = document.getElementById("hqX");
  const hqYEl = document.getElementById("hqY");
  const applyHQ = document.getElementById("applyHQ");
  const placeHQ = document.getElementById("placeHQ");

  const clearSel = document.getElementById("clearSel");
  const checkGrid = document.getElementById("checkGrid");

  const copyRoute = document.getElementById("copyRoute");
  const goSun = document.getElementById("goSun");
  const saveBtn = document.getElementById("saveBtn");
  const loadBtn = document.getElementById("loadBtn");

  const detailBack = document.getElementById("detailBack");
  const detail = document.getElementById("detail");
  const dClose = document.getElementById("dClose");
  const dTitle = document.getElementById("dTitle");
  const dSub = document.getElementById("dSub");
  const dEffect = document.getElementById("dEffect");
  const dLv = document.getElementById("dLv");
  const dSave = document.getElementById("dSave");
  const dCopy = document.getElementById("dCopy");

  const toastEl = document.getElementById("toast");
  const toast = (msg) => {
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=>toastEl.classList.remove("show"), 900);
  };
  async function copyText(text){
    try{ await navigator.clipboard.writeText(text); toast("コピーした！"); }
    catch{ prompt("手動コピーしてね", text); }
  }

  // ===== WORLD / ISO =====
  const WORLD_MIN = 0;
  const WORLD_MAX = 1200;

  // 見やすさ重視：控えめなアイソメ
  const SCALE = 0.85;        // iso倍率（world→screen）
  const TILE_W = 42;         // 見た目用
  const TILE_H = 22;

  function iso(x,y){
    return { sx:(x-y)*SCALE, sy:(x+y)*SCALE*0.5 };
  }

  // screen -> world（逆変換）
  const cam = { x:0, y:0, s:1 };
  const BASE = { x:0, y:0 };

  function screenToWorld(px,py){
    const x = (px - BASE.x - cam.x) / cam.s;
    const y = (py - BASE.y - cam.y) / cam.s;
    const X = (y/(SCALE*0.5) + x/SCALE) / 2;
    const Y = (y/(SCALE*0.5) - x/SCALE) / 2;
    return { x: Math.round(X), y: Math.round(Y) };
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
  function dist(a,b){ return Math.sqrt(dist2(a,b)); }

  // ===== Fixed objects =====
  const SUN = { x:597, y:597, label:"太陽城" };

  // 黄色ゾーン（通行不可）
  const NO_PASS = { x1:497, y1:497, x2:697, y2:697 };

  // 要塞・砦は「絶対表示」(接続しない)
  const FORTRESSES = [
    { id:1, x:597, y:800, label:"要塞1" },
    { id:2, x:400, y:597, label:"要塞2" },
    { id:3, x:597, y:400, label:"要塞3" },
    { id:4, x:800, y:597, label:"要塞4" },
  ];
  const FORTS = [
    [237,828],[237,606],[237,348],
    [366,237],[588,137],[846,237],
    [957,348],[957,606],[957,828],
    [846,957],[606,957],[306,957]
  ].map(([x,y],i)=>({ id:i+1, x, y, label:(i<4?`砦${i+1}`:"") }));

  // ===== Station coordinates (74) =====
  const STATIONS_RAW = [
    [138,327],[138,957],[237,138],[327,1038],[768,138],[957,1068],
    [1068,237],[1068,747],[87,666],[138,237],[267,1068],[537,87],
    [636,1137],[957,138],[1068,936],[1137,567],[138,138],[138,666],
    [138,1038],[537,138],[666,1068],[1068,138],[1068,567],[1068,1068],
    [327,666],[486,327],[768,867],[867,567],[237,237],[237,957],
    [267,537],[537,936],[666,267],[957,237],[936,537],[957,957],
    [327,327],[327,867],[867,327],[867,867],[138,747],[237,486],
    [486,138],[486,957],[768,237],[768,1038],[957,747],[1068,486],
    [138,438],[138,867],[366,138],[438,1068],[666,138],[738,957],
    [957,438],[1068,666],[387,486],[588,867],[816,486],[387,717],
    [588,327],[816,717],[327,567],[486,867],[768,327],[867,666]
  ];

  // ===== Official Effect Master ===== const EFFECT_MASTER = {   prod:  { name:"生産",   color:"#22c55e", levels:[1] },   gath:  { name:"採集",   color:"#a3e635", levels:[1] },    build: { name:"建築",   color:"#0ea5e9", levels:[1,3] },   tech:  { name:"技術",   color:"#8b5cf6", levels:[1,3] },    train: { name:"訓練",   color:"#06b6d4", levels:[2] },   march: { name:"遠征",   color:"#38bdf8", levels:[3] },    atk:   { name:"武器",   color:"#ef4444", levels:[2,4] },   def:   { name:"防御",   color:"#f59e0b", levels:[2,4] }, };  // effectById をここで作り直す const effectById = Object.fromEntries(   Object.entries(EFFECT_MASTER).map(([id,v])=>[     id,     { id, name:v.name, color:v.color }   ]) );  function makeLabel(effectId, lv){   const name = EFFECT_MASTER[effectId].name;   if(effectId === "atk" || effectId === "def"){     if(lv === 2) return `${name} 5%`;     if(lv === 4) return `${name} 8%`;   }   return `${name} Lv${lv}`; }  function buildEffectLevels(){   const list = [];   for(const [id, e] of Object.entries(EFFECT_MASTER)){     for(const lv of e.levels){       list.push({         key: `${id}:${lv}`,         effectId: id,         lv,         label: makeLabel(id, lv),         color: e.color       });     }   }   return list; }  const EFFECT_LEVELS = buildEffectLevels(); const elByKey = Object.fromEntries(EFFECT_LEVELS.map(x=>[x.key,x]));
  const EFFECTS = [
    { id:"prod",  name:"生産",     color:"#34d399" },
    { id:"gath",  name:"採取",     color:"#a3e635" },
    { id:"march", name:"行軍速度", color:"#60a5fa" },
    { id:"atk",   name:"攻撃",     color:"#ef4444" },
    { id:"def",   name:"防御",     color:"#f59e0b" },
    { id:"train", name:"訓練",     color:"#22c55e" },
    { id:"res",   name:"研究",     color:"#8b5cf6" },
    { id:"build", name:"建築",     color:"#0ea5e9" },
  ];
  const effectById = Object.fromEntries(EFFECTS.map(e=>[e.id,e]));

  const EFFECT_LEVELS = [];
  for(const e of EFFECTS){
    for(const lv of [1,2,3]){
      let label = `${e.name} Lv${lv}`;
      if(e.id==="atk" || e.id==="def" || e.id==="res" || e.id==="build"){
        if(lv===2) label = `${e.name} 5%`;
        if(lv===3) label = `${e.name} 8%`;
        if(lv===1) label = `${e.name} Lv1`;
      }
      EFFECT_LEVELS.push({
        key: `${e.id}:${lv}`,
        effectId: e.id,
        lv,
        label,
        color: e.color
      });
    }
  }
  const elByKey = Object.fromEntries(EFFECT_LEVELS.map(x=>[x.key,x]));

  // ===== Stations with assignment =====
  let stations = STATIONS_RAW.map(([x,y],i)=>({
    sid: i+1,
    key: `S${i+1}`,
    x,y,
    effectId: EFFECTS[i % EFFECTS.length].id,
    lv: (i % 3) + 1
  }));

  // ===== Alliance (1つ) =====
  let allyName = allyNameEl.value || "N9Q";
  let allyColor = allyColorEl.value || "#2b7cff";
  const HQ = { x: Number(hqXEl.value)||520, y:Number(hqYEl.value)||520 };

  function syncHQLabels(){
    hqXY.textContent = `X: ${HQ.x} / Y: ${HQ.y}`;
    hqXEl.value = HQ.x;
    hqYEl.value = HQ.y;
  }

  // ===== Selection state =====
  const selectedKeys = new Set(); // "effectId:lv"
  let chosenStations = [];        // { key, station }
  let edges = [];                 // MST edges: {a,b}
  let polylines = [];             // expanded for draw: [{points:[...]}]

  // ===== Stable camera sizing =====
  function resizeIfNeeded(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.floor(rect.width * devicePixelRatio);
    const h = Math.floor(rect.height * devicePixelRatio);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    BASE.x = rect.width / 2;
    BASE.y = rect.height / 2;
  }

  function centerOnWorld(x,y){
    const p = iso(x,y);
    cam.x = -p.sx * cam.s;
    cam.y = -p.sy * cam.s;
  }

  function fitWholeWorld(){
    const corners = [
      iso(WORLD_MIN, WORLD_MIN),
      iso(WORLD_MAX, WORLD_MIN),
      iso(WORLD_MIN, WORLD_MAX),
      iso(WORLD_MAX, WORLD_MAX),
    ];
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const c of corners){
      minX=Math.min(minX,c.sx); maxX=Math.max(maxX,c.sx);
      minY=Math.min(minY,c.sy); maxY=Math.max(maxY,c.sy);
    }
    const rect = canvas.getBoundingClientRect();
    const pad = 18;
    const w = (maxX-minX);
    const h = (maxY-minY);
    const s = Math.min((rect.width-pad*2)/w, (rect.height-pad*2)/h);
    cam.s = clamp(s, 0.30, 2.8);
    const cx = (minX+maxX)/2;
    const cy = (minY+maxY)/2;
    cam.x = -cx * cam.s;
    cam.y = -cy * cam.s;
  }

  // ===== No-pass intersection =====
  function pointInRect(p, r){
    return p.x>=r.x1 && p.x<=r.x2 && p.y>=r.y1 && p.y<=r.y2;
  }
  function segIntersectsRect(a,b,r){
    const minX = Math.min(a.x,b.x), maxX = Math.max(a.x,b.x);
    const minY = Math.min(a.y,b.y), maxY = Math.max(a.y,b.y);
    if(maxX < r.x1 || minX > r.x2 || maxY < r.y1 || minY > r.y2) return false;
    if(pointInRect(a,r) || pointInRect(b,r)) return true;
    const p1={x:r.x1,y:r.y1}, p2={x:r.x2,y:r.y1}, p3={x:r.x2,y:r.y2}, p4={x:r.x1,y:r.y2};
    return (
      segIntersect(a,b,p1,p2) ||
      segIntersect(a,b,p2,p3) ||
      segIntersect(a,b,p3,p4) ||
      segIntersect(a,b,p4,p1)
    );
  }
  function segIntersect(a,b,c,d){
    const o1 = orient(a,b,c);
    const o2 = orient(a,b,d);
    const o3 = orient(c,d,a);
    const o4 = orient(c,d,b);
    if(o1===0 && onSeg(a,c,b)) return true;
    if(o2===0 && onSeg(a,d,b)) return true;
    if(o3===0 && onSeg(c,a,d)) return true;
    if(o4===0 && onSeg(c,b,d)) return true;
    return (o1>0) !== (o2>0) && (o3>0) !== (o4>0);
  }
  function orient(a,b,c){
    const v = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    return v===0 ? 0 : (v>0 ? 1 : -1);
  }
  function onSeg(a,p,b){
    return Math.min(a.x,b.x) <= p.x && p.x <= Math.max(a.x,b.x) &&
           Math.min(a.y,b.y) <= p.y && p.y <= Math.max(a.y,b.y);
  }

  function routeAvoidNoPass(a,b){
    if(!segIntersectsRect(a,b,NO_PASS)) return [a,b];

    const m = 16;
    const corners = [
      { x:NO_PASS.x1-m, y:NO_PASS.y1-m },
      { x:NO_PASS.x2+m, y:NO_PASS.y1-m },
      { x:NO_PASS.x2+m, y:NO_PASS.y2+m },
      { x:NO_PASS.x1-m, y:NO_PASS.y2+m },
    ];

    let best = null;
    let bestScore = Infinity;

    for(const c of corners){
      const ok1 = !segIntersectsRect(a,c,NO_PASS);
      const ok2 = !segIntersectsRect(c,b,NO_PASS);
      const score = dist(a,c) + dist(c,b) + (ok1&&ok2 ? 0 : 999999);
      if(score < bestScore){
        bestScore = score;
        best = c;
      }
    }

    if(best && !segIntersectsRect(a,best,NO_PASS) && !segIntersectsRect(best,b,NO_PASS)){
      return [a,best,b];
    }

    const midCandidates = [
      [{x:NO_PASS.x1-m, y:NO_PASS.y1-m}, {x:NO_PASS.x2+m, y:NO_PASS.y1-m}],
      [{x:NO_PASS.x1-m, y:NO_PASS.y2+m}, {x:NO_PASS.x2+m, y:NO_PASS.y2+m}],
      [{x:NO_PASS.x1-m, y:NO_PASS.y1-m}, {x:NO_PASS.x1-m, y:NO_PASS.y2+m}],
      [{x:NO_PASS.x2+m, y:NO_PASS.y1-m}, {x:NO_PASS.x2+m, y:NO_PASS.y2+m}],
    ];

    let best2 = null;
    bestScore = Infinity;
    for(const [c1,c2] of midCandidates){
      const ok = !segIntersectsRect(a,c1,NO_PASS) && !segIntersectsRect(c1,c2,NO_PASS) && !segIntersectsRect(c2,b,NO_PASS);
      const score = dist(a,c1)+dist(c1,c2)+dist(c2,b) + (ok ? 0 : 999999);
      if(score < bestScore){ bestScore=score; best2=[c1,c2]; }
    }
    if(best2) return [a,best2[0],best2[1],b];

    return [a,b];
  }

  // ===== Pick nearest station for each checked effect+lv =====
  function pickChosenStations(){
    const used = new Set();
    chosenStations = [];

    for(const key of selectedKeys){
      const req = elByKey[key];
      const candidates = stations.filter(s => s.effectId===req.effectId && s.lv===req.lv && !used.has(s.sid));
      if(!candidates.length) continue;

      let best = candidates[0];
      let bestD = dist2(HQ, best);
      for(const s of candidates){
        const d = dist2(HQ, s);
        if(d < bestD){ bestD=d; best=s; }
      }
      used.add(best.sid);
      chosenStations.push({ key, station: best });
    }
    chosenStations.sort((a,b)=>dist2(HQ,a.station)-dist2(HQ,b.station));
  }

  // ===== MST =====
  function buildMST(){
    edges = [];
    const nodes = [
      { label:`${allyName} HQ`, x:HQ.x, y:HQ.y, kind:"hq" },
      ...chosenStations.map(cs=>{
        const req = elByKey[cs.key];
        return { label:req.label, x:cs.station.x, y:cs.station.y, kind:"st", sid: cs.station.sid };
      })
    ];
    if(nodes.length<=1) return;

    const inTree = new Set([0]);
    const best = Array(nodes.length).fill(null);
    for(let i=1;i<nodes.length;i++){
      best[i] = { from:0, d2: dist2(nodes[0], nodes[i]) };
    }

    while(inTree.size < nodes.length){
      let pick=-1, bestD=Infinity;
      for(let i=1;i<nodes.length;i++){
        if(inTree.has(i)) continue;
        if(best[i].d2 < bestD){ bestD=best[i].d2; pick=i; }
      }
      if(pick===-1) break;
      const from = best[pick].from;
      inTree.add(pick);
      edges.push({ a:nodes[from], b:nodes[pick] });

      for(let j=1;j<nodes.length;j++){
        if(inTree.has(j)) continue;
        const d = dist2(nodes[pick], nodes[j]);
        if(d < best[j].d2) best[j] = { from: pick, d2: d };
      }
    }
  }

  // ===== Expand edges =====
  function buildPolylines(){
    polylines = [];
    for(const e of edges){
      const a = {x:e.a.x, y:e.a.y, label:e.a.label};
      const b = {x:e.b.x, y:e.b.y, label:e.b.label};
      const pts = routeAvoidNoPass(a,b);
      polylines.push({ points: pts });
    }
  }

  // ===== Drawing helpers =====
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function diamond(sx,sy,w,h){
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + w/2, sy + h/2);
    ctx.lineTo(sx, sy + h);
    ctx.lineTo(sx - w/2, sy + h/2);
    ctx.closePath();
  }

  function drawBackground(){
    ctx.fillStyle = "#050b1a";
    ctx.fillRect(-99999,-99999,199998,199998);

    ctx.strokeStyle = "rgba(255,255,255,0.025)";
    ctx.lineWidth = 0.7;
    const step = 60;
    for(let y=0; y<=WORLD_MAX; y+=step){
      for(let x=0; x<=WORLD_MAX; x+=step){
        const p = iso(x,y);
        ctx.fillStyle = "rgba(160,210,255,0.028)";
        diamond(p.sx, p.sy, TILE_W, TILE_H);
        ctx.fill();
        ctx.stroke();
      }
    }
  }

  function drawNoPassZone(){
    const p11 = iso(NO_PASS.x1, NO_PASS.y1);
    const p12 = iso(NO_PASS.x2, NO_PASS.y1);
    const p22 = iso(NO_PASS.x2, NO_PASS.y2);
    const p21 = iso(NO_PASS.x1, NO_PASS.y2);

    ctx.beginPath();
    ctx.moveTo(p11.sx, p11.sy);
    ctx.lineTo(p12.sx, p12.sy);
    ctx.lineTo(p22.sx, p22.sy);
    ctx.lineTo(p21.sx, p21.sy);
    ctx.closePath();

    ctx.fillStyle = "rgba(245, 158, 11, 0.18)";
    ctx.fill();
    ctx.strokeStyle = "rgba(245, 158, 11, 0.35)";
    ctx.lineWidth = 2;
    ctx.stroke();

    const c = iso((NO_PASS.x1+NO_PASS.x2)/2, (NO_PASS.y1+NO_PASS.y2)/2);
    ctx.fillStyle = "rgba(245,158,11,0.95)";
    ctx.font = "900 12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("通行不可", c.sx, c.sy - 10);
  }

  function drawSun(){
    const p = iso(SUN.x,SUN.y);
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.ellipse(p.sx, p.sy + TILE_H*0.9, TILE_W*0.48, TILE_H*0.48, 0, 0, Math.PI*2);
    ctx.fill();

    const w=TILE_W*1.2, h=TILE_H*2.0;
    const x=p.sx-w/2, y=p.sy-h;
    roundRect(x,y,w,h,14);
    ctx.fillStyle="#f7c948";
    ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.35)";
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.fillStyle="#10131c";
    ctx.font="900 12px system-ui";
    ctx.textAlign="center";
    ctx.fillText("太陽城", p.sx, y + h/2 + 4);
  }

  function drawFortresses(){
    for(const f of FORTRESSES){
      const p = iso(f.x,f.y);
      ctx.fillStyle="rgba(0,0,0,.25)";
      ctx.beginPath();
      ctx.ellipse(p.sx, p.sy + TILE_H*0.7, TILE_W*0.40, TILE_H*0.40, 0, 0, Math.PI*2);
      ctx.fill();

      const w=TILE_W*1.05, h=TILE_H*1.6;
      const x=p.sx-w/2, y=p.sy-h;
      roundRect(x,y,w,h,12);
      ctx.fillStyle="#4aa3ff";
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.24)";
      ctx.lineWidth=2.2;
      ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font="800 11px system-ui";
      ctx.textAlign="center";
      ctx.fillText(f.label, p.sx, y-6);
    }
  }

  function drawForts(){
    for(const ft of FORTS){
      const p = iso(ft.x,ft.y);
      ctx.fillStyle="rgba(0,0,0,.20)";
      ctx.beginPath();
      ctx.ellipse(p.sx, p.sy + TILE_H*0.55, TILE_W*0.28, TILE_H*0.28, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle="#19c37d";
      ctx.beginPath();
      ctx.arc(p.sx, p.sy - 8, 6.5, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.25)";
      ctx.lineWidth=2;
      ctx.stroke();

      if(ft.label){
        ctx.fillStyle="rgba(255,255,255,.85)";
        ctx.font="800 11px system-ui";
        ctx.textAlign="center";
        ctx.fillText(ft.label, p.sx, p.sy - 22);
      }
    }
  }

  function drawStations(){
    const sorted = [...stations].sort((a,b)=>(a.x+a.y)-(b.x+b.y));
    for(const s of sorted){
      const p = iso(s.x,s.y);
      const eff = effectById[s.effectId] || EFFECTS[0];

      ctx.fillStyle = "rgba(255,255,255,.22)";
      ctx.beginPath();
      ctx.arc(p.sx, p.sy - 1, 3.2, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = eff.color;
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy - 1, 5.6, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = "900 10px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(String(s.lv), p.sx, p.sy - 10);
    }
  }

  function drawChosenAndRoute(){
    // ★線が確実に見える太さ（確認用：後で細くしてOK）
    const SHADOW_W = 12;
    const MAIN_W = 6;

    if(polylines.length){
      ctx.strokeStyle="rgba(0,0,0,.45)";
      ctx.lineWidth=SHADOW_W;
      ctx.lineCap="round";
      ctx.lineJoin="round";
      ctx.beginPath();
      for(const pl of polylines){
        const pts = pl.points;
        for(let i=0;i<pts.length-1;i++){
          const a = iso(pts[i].x, pts[i].y);
          const b = iso(pts[i+1].x, pts[i+1].y);
          ctx.moveTo(a.sx, a.sy);
          ctx.lineTo(b.sx, b.sy);
        }
      }
      ctx.stroke();

      ctx.strokeStyle = allyColor;
      ctx.lineWidth=MAIN_W;
      ctx.beginPath();
      for(const pl of polylines){
        const pts = pl.points;
        for(let i=0;i<pts.length-1;i++){
          const a = iso(pts[i].x, pts[i].y);
          const b = iso(pts[i+1].x, pts[i+1].y);
          ctx.moveTo(a.sx, a.sy);
          ctx.lineTo(b.sx, b.sy);
        }
      }
      ctx.stroke();
    }

    for(const cs of chosenStations){
      const s = cs.station;
      const req = elByKey[cs.key];
      const p = iso(s.x,s.y);

      ctx.fillStyle = allyColor;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy - 1, 7.2, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy - 1, 7.2, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle="#fff";
      ctx.font="900 12px system-ui";
      ctx.textAlign="center";
      ctx.fillText(req.label, p.sx, p.sy - 16);
    }
  }

  function drawHQ(){
    const p = iso(HQ.x,HQ.y);
    ctx.fillStyle="rgba(0,0,0,.38)";
    ctx.beginPath();
    ctx.ellipse(p.sx, p.sy + TILE_H*0.9, TILE_W*0.48, TILE_H*0.48, 0, 0, Math.PI*2);
    ctx.fill();

    const w=TILE_W*1.25, h=TILE_H*2.05;
    const x=p.sx-w/2, y=p.sy-h;
    roundRect(x,y,w,h,14);
    ctx.fillStyle=allyColor;
    ctx.fill();
    ctx.strokeStyle="#ffffff";
    ctx.lineWidth=3.2;
    ctx.stroke();

    ctx.fillStyle="#fff";
    ctx.font="900 14px system-ui";
    ctx.textAlign="center";
    ctx.fillText(`${allyName} HQ`, p.sx, y-6);
  }

  function draw(){
    resizeIfNeeded();

    // ✅ ここが“線が出ない”致命傷の修正（DPRで壊れないクリア）
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

    ctx.save();
    ctx.translate(BASE.x + cam.x, BASE.y + cam.y);
    ctx.scale(cam.s, cam.s);

    drawBackground();
    drawNoPassZone();
    drawStations();
    drawSun();
    drawFortresses();
    drawForts();
    drawChosenAndRoute();
    drawHQ();

    ctx.restore();
  }

  // ===== Checklist =====
  function renderChecklist(){
    checkGrid.innerHTML = "";
    for(const item of EFFECT_LEVELS){
      const row = document.createElement("div");
      row.className = "check";

      const left = document.createElement("div");
      left.className = "left";

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = selectedKeys.has(item.key);
      chk.addEventListener("change", ()=>{
        if(chk.checked) selectedKeys.add(item.key);
        else selectedKeys.delete(item.key);
        selPill.textContent = `選択 ${selectedKeys.size}`;
      });

      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = item.color;

      const nm = document.createElement("div");
      nm.style.minWidth = 0;

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = item.label;

      const sub = document.createElement("div");
      sub.className = "sub";
      const cnt = stations.filter(s => s.effectId===item.effectId && s.lv===item.lv).length;
      sub.textContent = `候補 ${cnt}`;

      nm.appendChild(name);
      nm.appendChild(sub);

      left.appendChild(chk);
      left.appendChild(dot);
      left.appendChild(nm);

      row.appendChild(left);
      checkGrid.appendChild(row);
    }
    selPill.textContent = `選択 ${selectedKeys.size}`;
  }

  // ===== Sheet =====
  function openSheet(){
    sheetBack.classList.add("open");
    sheet.classList.add("open");
    renderChecklist();
  }
  function closeSheetFn(){
    sheetBack.classList.remove("open");
    sheet.classList.remove("open");
  }
  menuBtn.addEventListener("click", openSheet);
  closeSheet.addEventListener("click", closeSheetFn);
  sheetBack.addEventListener("click", closeSheetFn);

  // ===== HQ controls =====
  allyNameEl.addEventListener("input", ()=>{ allyName = allyNameEl.value || "N9Q"; draw(); });
  allyColorEl.addEventListener("input", ()=>{ allyColor = allyColorEl.value || "#2b7cff"; draw(); });

  applyHQ.addEventListener("click", ()=>{
    const x = Number(hqXEl.value), y = Number(hqYEl.value);
    if(!Number.isFinite(x) || !Number.isFinite(y)){ toast("HQ座標が変だよ"); return; }
    HQ.x = clamp(Math.round(x), WORLD_MIN, WORLD_MAX);
    HQ.y = clamp(Math.round(y), WORLD_MIN, WORLD_MAX);
    syncHQLabels();
    toast("HQ反映");
    draw();
  });

  let placeHQMode = false;
  placeHQ.addEventListener("click", ()=>{
    placeHQMode = true;
    toast("マップをタップしてHQ配置");
    closeSheetFn();
  });

  // ===== Route button =====
  function buildRoute(){
    if(selectedKeys.size===0){ toast("効果をチェックしてね"); return; }
    pickChosenStations();
    buildPolylines();
    toast(`採用 ${chosenStations.length} / 12`);
  }
  routeBtn.addEventListener("click", buildRoute);

  clearSel.addEventListener("click", ()=>{
    selectedKeys.clear();
    chosenStations = [];
    edges = [];
    polylines = [];
    selPill.textContent = "選択 0";
    renderChecklist();
    draw();
    toast("全外し");
  });

  // ===== Copy / Go / Save / Load =====
  copyRoute.addEventListener("click", ()=>{
    const lines = [];
    lines.push(`同盟: ${allyName}`);
    lines.push(`色: ${allyColor}`);
    lines.push(`HQ: (${HQ.x}, ${HQ.y})`);
    lines.push(``);
    lines.push(`チェック: ${[...selectedKeys].map(k=>elByKey[k].label).join(" / ") || "(なし)"}`);
    lines.push(``);
    lines.push(`採用（HQ最寄り）:`);
    for(const cs of chosenStations){
      const s = cs.station;
      const req = elByKey[cs.key];
      lines.push(`- ${req.label}: ${s.key} (${s.x},${s.y})`);
    }
    lines.push(``);
    lines.push(`ルート（回避済み折れ線）:`);
    if(!polylines.length) lines.push("(未作成)");
    else{
      let i=1;
      for(const pl of polylines){
        const pts = pl.points.map(p=>`(${p.x},${p.y})`).join(" -> ");
        lines.push(`${i++}. ${pts}`);
      }
    }
    copyText(lines.join("\n"));
  });

  goSun.addEventListener("click", ()=>{
    centerOnWorld(SUN.x,SUN.y);
    toast("太陽城へ");
    function draw(){   resizeIfNeeded();    // ★① まず transform をリセット   ctx.setTransform(1,0,0,1,0,0);    // ★② 実ピクセルでクリア   ctx.clearRect(0,0,canvas.width,canvas.height);    // ★③ DPR を適用   ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);    ctx.save();   ctx.translate(BASE.x + cam.x, BASE.y + cam.y);   ctx.scale(cam.s, cam.s);    // --- ここから描画 ---   drawBackground();   drawNoPassZone();   drawStations();   drawChosenAndRoute(); // ← 線   drawHQ();    ctx.restore(); };
  });

  saveBtn.addEventListener("click", ()=>{
    const payload = {
      version: 2,
      allyName, allyColor,
      HQ,
      selectedKeys: [...selectedKeys],
      stations,
      cam
    };
    prompt("このJSONをコピーして保存してね", JSON.stringify(payload, null, 2));
  });

  loadBtn.addEventListener("click", ()=>{
    const txt = prompt("保存したJSONを貼り付けてね");
    if(!txt) return;
    try{
      const obj = JSON.parse(txt);
      if(obj.allyName) allyName = allyNameEl.value = obj.allyName;
      if(obj.allyColor) allyColor = allyColorEl.value = obj.allyColor;

      if(obj.HQ){
        HQ.x = clamp(Math.round(obj.HQ.x||HQ.x), WORLD_MIN, WORLD_MAX);
        HQ.y = clamp(Math.round(obj.HQ.y||HQ.y), WORLD_MIN, WORLD_MAX);
        syncHQLabels();
      }
      if(Array.isArray(obj.stations)) stations = obj.stations;

      selectedKeys.clear();
      if(Array.isArray(obj.selectedKeys)) obj.selectedKeys.forEach(k=>selectedKeys.add(k));
      selPill.textContent = `選択 ${selectedKeys.size}`;

      if(obj.cam){
        cam.x = obj.cam.x||0; cam.y = obj.cam.y||0; cam.s = obj.cam.s||1;
      }

      chosenStations = [];
      edges = [];
      polylines = [];
      renderChecklist();
      draw();
      toast("読込OK");
    }catch(e){
      alert("JSONが壊れてるかも…");
    }
  });

  // ===== Full / Reset =====
  fullBtn.addEventListener("click", ()=>{
    fitWholeWorld();
    draw();
    toast("全体表示");
  });

  resetBtn.addEventListener("click", ()=>{
    cam.s = 1;
    centerOnWorld(SUN.x,SUN.y);
    chosenStations = [];
    edges = [];
    polylines = [];
    tapXY.textContent = `X: -  /  Y: -`;
    ctx.strokeStyle = "red"; ctx.lineWidth = 10; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(200,200); ctx.stroke();;
    toast("リセット");
  });

  // ===== Station hit test =====
  function nearestStationAt(px,py){
    const w = screenToWorld(px,py);
    let best = stations[0];
    let bestD = dist2(w, best);
    for(const s of stations){
      const d = dist2(w, s);
      if(d < bestD){ bestD=d; best=s; }
    }
    return { station: best, worldTap: w, d2: bestD };
  }

  // detail modal
  let detailStation = null;
  function openDetail(s){
    detailStation = s;
    dTitle.textContent = `${s.key} の割当`;
    const eff = effectById[s.effectId];
    dSub.textContent = `${eff?.name || s.effectId} / Lv${s.lv}   座標 (${s.x}, ${s.y})`;

    dEffect.innerHTML = "";
    for(const e of EFFECTS){
      const opt = document.createElement("option");
      opt.value = e.id;
      opt.textContent = e.name;
      dEffect.appendChild(opt);
    }
    dEffect.value = s.effectId;
    dLv.value = String(s.lv);

    detailBack.style.display = "block";
    detail.style.display = "block";
  }
  function closeDetail(){
    detailBack.style.display = "none";
    detail.style.display = "none";
    detailStation = null;
  }
  dClose.addEventListener("click", closeDetail);
  detailBack.addEventListener("click", closeDetail);

  dSave.addEventListener("click", ()=>{
    if(!detailStation) return;
    detailStation.effectId = dEffect.value;
    detailStation.lv = Number(dLv.value);
    const eff = effectById[detailStation.effectId];
    dSub.textContent = `${eff?.name || detailStation.effectId} / Lv${detailStation.lv}   座標 (${detailStation.x}, ${detailStation.y})`;
    renderChecklist();
    draw();
    toast("割当保存");
  });

  dCopy.addEventListener("click", ()=>{
    if(!detailStation) return;
    const eff = effectById[detailStation.effectId];
    const txt = `${detailStation.key} / ${eff?.name || detailStation.effectId} Lv${detailStation.lv} / (${detailStation.x}, ${detailStation.y})`;
    copyText(txt);
  });

  // ===== Touch / Pan / Pinch =====
  const pointers = new Map();
  let lastPan = null;
  let pinchStart = null;

  function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
  function len(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }

  canvas.addEventListener("pointerdown",(e)=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
    if(pointers.size===1){
      lastPan = {x:e.clientX,y:e.clientY};
    }else if(pointers.size===2){
      const [p1,p2] = [...pointers.values()];
      pinchStart = { mid: midpoint(p1,p2), dist: len(p1,p2), camS: cam.s, camX: cam.x, camY: cam.y };
    }
  });

  canvas.addEventListener("pointermove",(e)=>{
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});

    if(pointers.size===1 && lastPan){
      const dx = e.clientX - lastPan.x;
      const dy = e.clientY - lastPan.y;
      lastPan = {x:e.clientX,y:e.clientY};
      cam.x += dx;
      cam.y += dy;
      draw();
    }else if(pointers.size===2 && pinchStart){
      const [p1,p2] = [...pointers.values()];
      const mid = midpoint(p1,p2);
      const d = len(p1,p2);
      const factor = d / pinchStart.dist;

      cam.s = clamp(pinchStart.camS * factor, 0.30, 3.2);

      cam.x = pinchStart.camX + (mid.x - pinchStart.mid.x);
      cam.y = pinchStart.camY + (mid.y - pinchStart.mid.y);
      draw();
    }
  });

  function endPointer(e){
    pointers.delete(e.pointerId);
    if(pointers.size===0){ lastPan=null; pinchStart=null; }
    else if(pointers.size===1){
      const [p] = [...pointers.values()];
      lastPan = {x:p.x,y:p.y};
      pinchStart=null;
    }
  }
  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);

  // Tap / click logic
  canvas.addEventListener("click",(e)=>{
    const w = screenToWorld(e.clientX, e.clientY);
    tapXY.textContent = `X: ${clamp(w.x,WORLD_MIN,WORLD_MAX)}  /  Y: ${clamp(w.y,WORLD_MIN,WORLD_MAX)}`;

    if(placeHQMode){
      HQ.x = clamp(w.x, WORLD_MIN, WORLD_MAX);
      HQ.y = clamp(w.y, WORLD_MIN, WORLD_MAX);
      syncHQLabels();
      placeHQMode = false;
      toast("HQ配置OK");
      draw();
      return;
    }

    const hit = nearestStationAt(e.clientX, e.clientY);
    if(hit.d2 <= 40*40){
      openDetail(hit.station);
    }
  });

  // wheel zoom (PC)
  canvas.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.001);
    cam.s = clamp(cam.s * factor, 0.30, 3.2);
    draw();
  }, {passive:false});

  // ===== Boot =====
  function boot(){
    resizeIfNeeded();
    cam.s = 1;
    centerOnWorld(SUN.x,SUN.y);
    syncHQLabels();
    renderChecklist();

    dEffect.innerHTML = "";
    for(const e of EFFECTS){
      const opt = document.createElement("option");
      opt.value = e.id;
      opt.textContent = e.name;
      dEffect.appendChild(opt);
    }

    draw();
  }
  window.addEventListener("resize", ()=>{ resizeIfNeeded(); draw(); });
  boot();
})();
</script>
</body>
</html>